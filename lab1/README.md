
# ФИО

---

**Студент:** Крохин Роман Олегович  
**ИСУ:** 368381  
**Группа:** P3324  
**Университет:** НИУ ИТМО  
**Факультет:** Программная инженерия и компьютерная техника  
**Курс:** 3-й курс  

---

# Отчет по решениям задач 8 и 23 с Project Euler

В этом проекте представлено несколько решений для задач с сайта Project Euler. Решения реализованы на языке Clojure и включают разные подходы для вычисления максимального произведения последовательностей цифр, а также методы для работы с обильными числами. Ниже приводится анализ каждого решения.

## Решения для Задачи 8

Задача 8 заключается в нахождении наибольшего произведения четырёх последовательных цифр в строке чисел. Приведено несколько подходов к решению задачи с использованием рекурсии, хвостовой рекурсии, модулярности, и других методов.

### 1. Хвостовая рекурсия: `task8tailrec`
Этот модуль использует хвостовую рекурсию для нахождения произведения цифр. Основная функция:
```clojure
(defn product-tail [digits acc]
  (if (empty? digits)
    acc
    (recur (rest digits) (* acc (first digits)))))
```
Процесс делится на части с помощью функции `partition`, которая разбивает цифры на группы по четыре и находит их произведение через хвостовую рекурсию. Решение эффективно для последовательных операций и избегает переполнения стека.

[Решение](task8-23/src/task8_23/task8tailrec.clj)

### 2. Рекурсия: `task8rec`
Это решение использует простую рекурсию для вычисления произведения последовательностей:
```clojure
(defn product-rec [digits]
  (if (empty? digits)
    1
    (* (first digits) (product-rec (rest digits)))))
```
Здесь каждая группа цифр обрабатывается с помощью рекурсивного умножения, а затем находится максимальное произведение среди всех групп.

[Решение](task8-23/src/task8_23/task8rec.clj)

### 3. Модульное решение: `task8module`
Модульное решение использует функции высшего порядка для модульности и фильтрации:
```clojure
(defn max-product-modular [n]
  (->> n
       generate-sequences
       filter-sequences
       (map product)
       (apply max)))
```
Это решение более читабельно за счёт использования композиции функций и подходит для функционального стиля программирования.

[Решение](./task8-23/src/task8-23/task8module.clj)

### 4. Использование `map`: `task8map`
Этот модуль использует функцию `map`, чтобы применить умножение ко всем четырёхзначным группам:
```clojure
(defn max-product-map [n]
  (apply max (map #(apply * %) (partition 4 1 (map #(Character/digit % 10) n)))))
```
Решение лаконично и эффективно для обработки последовательностей с минимальным количеством кода.

### 5. `loop` решение: `task8loop`
Решение с использованием цикла `loop` аналогично хвостовой рекурсии:
```clojure
(defn max-product-loop [n]
  (let [digits (map #(Character/digit % 10) n)]
    (loop [parts (partition 4 1 digits)
           max-prod 0]
      (if (empty? parts)
        max-prod
        (recur (rest parts) (max (apply * (first parts)) max-prod))))))
```
Цикл позволяет избежать необходимости рекурсивного вызова, тем самым оптимизируя использование ресурсов.

[Решение](./task8-23/src/task8-23/task8loop.clj)

### 6. Бесконечная последовательность: `task8inf`
В этом решении создаётся бесконечная последовательность цифр:
```clojure
(defn infinite-sequence [n]
  (->> n
       (map #(Character/digit % 10))
       cycle))
```
Такой подход позволяет работать с циклическими последовательностями и находить максимальное произведение в длинных строках.

[Решение](./task8-23/src/task8-23/task8inf.clj)

## Решения для Задачи 23

Задача 23 (Project Euler): Нахождение суммы всех чисел, которые не могут быть записаны как сумма двух избыточных чисел.

### 1. **Хвостовая рекурсия (`task23tailrec`)**
Этот модуль применяет хвостовую рекурсию для эффективного вычисления:

```clojure
(defn find-abundant-numbers-tail-rec [n]
  (loop [i 1, abundants []]
    (if (> i n)
      abundants
      (recur (inc i) (if (abundant? i) (conj abundants i) abundants)))))
```

Лаконичное и эффективное решение для нахождения всех избыточных чисел с использованием хвостовой рекурсии, что позволяет избежать переполнения стека.

[Решение](./task8-23/src/task8-23/task23tailrec.clj)

### 2. **Рекурсия (`task23rec`)**
Этот модуль использует стандартную рекурсию для нахождения суммы делителей и проверки чисел:

```clojure
(defn abundant? [n]
  (> (sum-divisors n) n))
```

Простое рекурсивное решение для проверки чисел на избыточность.

[Решение](./task8-23/src/task8-23/task23rec.clj)

### 3. **Модульное решение (`task23modular`)**
Модульное решение структурирует код для удобного использования функций:

```clojure
(defn sum-of-non-abundant-sums-modular [n]
  (reduce + (filter #(not (can-be-sum-of-two-abundant? %)) (range 1 n))))
```

Каждая функция отвечает за определенную задачу, что делает код читаемым и расширяемым.

[Решение](./task8-23/src/task8-23/task23modular.clj)

### 4. **Использование `map` (`task23map`)**
Этот модуль применяет `map` для применения функций к последовательностям:

```clojure
(defn sum-of-divisors-map [n]
  (apply + (map #(if (zero? (mod n %)) % 0) (range 1 n))))
```

Использование `map` делает код кратким и эффективным при обработке последовательностей.

[Решение](./task8-23/src/task8-23/task23map.clj)

### 5. **Использование циклов (`task23loop`)**
Циклы используются для итеративного решения задачи:

```clojure
(defn find-abundant-numbers-loop [n]
  (loop [i 1 abundants []]
    (if (> i n)
      abundants
      (recur (inc i) (if (abundant? i) (conj abundants i) abundants)))))
```

Циклы обеспечивают предсказуемое выполнение и быстрое решение.

[Решение](./task8-23/src/task8-23/task23loop.clj)

### 6. **Бесконечные последовательности (`task23inf`)**
Решение использует бесконечные последовательности для поиска чисел:

```clojure
(defn abundant-seq []
  (filter abundant? (range 1)))
```

Позволяет работать с потенциально бесконечными данными.

[Решение](./task8-23/src/task8-23/task23inf.clj)

## Заключение

Представленные решения демонстрируют разные подходы к решению задач с использованием функционального программирования в Clojure. Эти примеры показывают, как рекурсия, циклы и функции высшего порядка могут быть использованы для эффективного решения математических задач.
